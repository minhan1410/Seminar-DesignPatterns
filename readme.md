# Design Patterns

## Đặt vấn đề

- Trong quá trình phát triển phần mềm, phần lớn thời gian không phải là viết code từ đầu mà là maintain và đọc hiểu code cũ. Vì vậy, cần xây dựng code như thế nào để những người vào sau có thể dễ dàng đọc hiểu?

- Trong phát triển phần mềm, sẽ không thể tránh khỏi các sự thay đổi yêu cầu từ phía khách hàng. Vậy làm thế nào để sau khi thay đổi không ảnh hưởng đến code cũ?

  > Từ những vấn đề trên, nhóm **GOF** đã ngồi lại và xuất bản cuốn sách về **Design Patterns**. Cuốn sách này được xây dựng từ kinh nghiệm của các chuyên gia đi trước, cung cấp các nguyên lý và mẫu thiết kế giúp dễ dàng mở rộng, maintain và thay đổi hệ thống mà ít ảnh hưởng đến toàn bộ codebase.

## Tác giả

- **Gang of Four (GoF)** là một nhóm gồm 4 tác giả nổi tiếng trong lĩnh vực thiết kế phần mềm, bao gồm:
  1. Erich Gamma
  1. Richard Helm
  1. Ralph Johnson
  1. John Vlissides

- Năm 1994, họ đã xuất bản cuốn sách "**Design Patterns: Elements of Reusable Object-Oriented Software" (Thiết kế phần mềm: Các yếu tố của phần mềm hướng đối tượng có thể tái sử dụng)**, trong đó họ đã giới thiệu và mô tả về các design pattern để giúp các nhà phát triển tạo ra các hệ thống phần mềm chất lượng cao, dễ dàng bảo trì và mở rộng.

## Định nghĩa

- Design pattern là một kỹ thuật trong lập trình hướng đối tượng, nó không phải là code mà là các giải pháp đã được tối
  ưu hoá nhằm giải quyết các vấn đề phổ biến trong khi lập trình.

## Ưu, nhược điểm

- **Ưu điểm**

  - Design Pattern giúp code dễ dàng mở rộng và tái sử dụng hơn.

  - Code clear hơn, dễ dàng đọc hiểu hơn(Nếu mọi người trong team đều biết về Design Patterns)

  - Giúp tăng tốc độ phát triển phần mềm vì nó là các giải pháp đã được tối ưu, đã được kiểm thử để giải quyết các vấn
      đề trong quá trình phát triển phần mềm

  - Sử dụng design pattern giúp tránh được các vấn đề tiềm ẩn và dễ dàng nâng cấp, bảo trì sau này

- **Nhược điểm**

  - Code trở nên phức tạp hơn đặc biệt là khi áp dụng nhiều design pattern cùng 1 lúc

  - không phải là giải pháp phù hợp cho mọi tình huống và có thể không hiệu quả trong một số trường hợp

## [Phân loại các design pattern](https://refactoring.guru/design-patterns/catalog)

| **Loại** | **Tên** | **Chi tiết** |
|:---:|:---:|---|
| **Creational Pattern (Mẫu Khởi tạo)**<br>Các pattern này giúp quản lý **quá trình tạo đối tượng**. Thay vì trực tiếp sử dụng từ khóa `new` để khởi tạo đối tượng, các pattern này cung cấp cách thức linh hoạt hơn, giúp ẩn đi chi tiết phức tạp trong việc tạo đối tượng. |  |  |
|  | **Singleton Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/singleton-mini-2x.png)<br><br>**Độ khó**: ★☆☆☆☆<br>**Mức độ phổ biến**: ★★★★☆ | **1. Định nghĩa**<br>- Đảm bảo chỉ duy nhất một thể hiện (instance) được tạo ra và nó sẽ cung cấp cho bạn một method để có thể truy xuất được thể hiện duy nhất đó mọi lúc mọi nơi trong chương trình.<br><img src="https://refactoring.guru/images/patterns/content/singleton/singleton-2x.png?id=accb2cc7594f7a491ce01dddf0d2f876" width="auto" height="200"><br><br>**2. Ứng dụng**<br>- Vì class dùng Singleton chỉ tồn tại 1 Instance nên nó thường được dùng cho các trường hợp giải quyết các bài toán cần truy cập vào các ứng dụng như: Logger, Configuration, Kêt nối DB, dịch vụ HTTP client, Shared resource, Caching, Thread pool, …<br>- Một số design pattern khác cũng sử dụng Singleton để triển khai: Abstract Factory, Builder, Prototype, Facade,…<br>- Đã được sử dụng trong một số class của core java như: java.lang.Runtime, java.awt.Desktop.<br><br>**3. Ưu, nhược điểm**<br><br>- **Ưu điểm**: Đảm bảo chỉ tồn tại 1 Instance duy nhất giúp tiết kiệm bộ nhớ, dễ dàng quản lý đối tượng.<br><br>- **Nhược điểm**: Khó test và mở rộng (đặc biệt trong môi trường multi-threading nếu không quản lý cẩn thận).<br><br>**4. Cách triển khai**<br>    1. Đặt private constructor để hạn chế truy cập từ class bên ngoài.<br>    2. Đặt private static final variable đảm bảo biến chỉ được khởi tạo trong class.<br>    3. Có một method public static để return instance được khởi tạo ở trên.<br><br>**[5. Ví dụ](designPattern.md#singleton-pattern)** |
|  | **Factory Method Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/factory-method-mini-2x.png)<br><br>**Độ khó**: ★★☆☆☆<br>**Mức độ phổ biến**: ★★★★★ | **1. Định nghĩa**<br>- Là pattern giúp cho việc khởi tạo đổi tượng một cách linh hoạt, giảm thiểu sự phụ thuộc giữa các class, dễ dàng mở rộng code<br><img src="https://refactoring.guru/images/patterns/content/factory-method/factory-method-en-2x.png?id=b3961995a4449fb90820a693013511df" width="auto" height="200"><br><br>**2. Ứng dụng**<br>- Khi bạn không biết trước kiểu và các phụ thuộc của object mà code sẽ làm việc với nó.<br>- Khi bạn muốn cung cấp cho người dùng thư viện hoặc framework của bạn một cách để mở rộng các thành phần sẵn có bên trong nó.<br>- Khi bạn muốn tiết kiệm tài nguyên hệ thống bằng việc tái sử dụng các object đã có thay vì xây dựng lại mỗi lần có thêm sản phẩm mới.<br><br>**3. Ưu, nhược điểm**<br><br>- **Ưu điểm**:<br>    - Giảm sự phụ thuộc giữa các object<br>    - Mở rộng code dễ dàng hơn<br>    - Thống nhất về naming convention: giúp cho các developer có thể hiểu về cấu trúc source code.<br><br>- **Nhược điểm**: Code sẽ trở nên phức tạp khi có quá nhiều class con để triển khai pattern<br><br>**4. Cách triển khai**<br>- **Super Class**: môt supper class trong Factory Pattern có thể là một interface, abstract class hay một class thông thường.<br>- **Sub Classes**: các sub class sẽ implement các phương thức của supper class theo nghiệp vụ riêng của nó.<br>- **Factory Class**: một class chịu tránh nhiệm khởi tạo các đối tượng sub class dựa theo tham số đầu vào. Lưu ý: lớp này là Singleton hoặc cung cấp một public static method cho việc truy xuất và khởi tạo đối tượng. Factory class sử dụng if-else hoặc switch-case để xác định class con đầu ra.<br><br>**[5. Ví dụ](designPattern.md#factory-pattern)** |
|  | **Abstract Factory Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/abstract-factory-mini-2x.png)<br><br>**Độ khó**: ★★★★☆<br>**Mức độ phổ biến**: ★★★★★ | **1. Định nghĩa**<br>- Là phương pháp tạo ra một Super-factory dùng để tạo ra các Factory khác. Hay còn được gọi là Factory của các Factory. Abstract Factory Pattern là một Pattern cấp cao hơn so với Factory Method Pattern.<br><img src="https://refactoring.guru/images/patterns/content/abstract-factory/abstract-factory-en-2x.png?id=a488ca862db731876fa0513bb2105640" width="auto" height="200"> |
|  | **Prototype Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/prototype-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★☆☆ | **1. Định nghĩa**<br>- Nó có nhiệm vụ khởi tạo một đối tượng bằng cách **clone** một đối tượng đã tồn tại thay vì khởi tạo với từ khoá `new`. Đối tượng mới là một bản sao có thể giống 100% với đối tượng gốc, chúng ta có thể thay đổi dữ liệu của nó mà không ảnh hưởng đến đối tượng gốc.<br><img src="https://refactoring.guru/images/patterns/content/prototype/prototype-2x.png?id=670789c80c8a114e25838ede2da4a881" width="auto" height="200"> |
|  | **Builder Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/builder-mini-2x.png)<br><br>**Độ khó**: ★★★★☆<br>**Mức độ phổ biến**: ★★☆☆☆ | **1. Định nghĩa**<br>- Là pattern giúp bạn tạo đối tượng phức tạp bằng cách chia nhỏ quá trình khởi tạo thành từng bước. Nó cung cấp các method để cấu hình từng thuộc tính, giúp việc tạo đối tượng dễ dàng hơn.<br><img src="https://refactoring.guru/images/patterns/content/builder/builder-en-2x.png?id=8da2aa97abfdabf265e622579fc448a1" width="auto" height="200"><br><br>**2. Ứng dụng**<br>- Khi đối tượng có nhiều thuộc tính cần khởi tạo và có thể biến đổi linh hoạt<br><br>**3. Ưu, nhược điểm**<br><br>- **Ưu điểm**: Giảm sự phức tạp khi khởi tạo các đối tượng lớn. Dễ mở rộng và linh hoạt trong việc khởi tạo các thuộc tính không bắt buộc.<br><br>- **Nhược điểm**: Tốn bộ nhớ hơn do cần tạo thêm các lớp Builder.<br><br>**4. Cách triển khai**<br>Một builder gồm các thành phần cơ bản sau:<br>- **Product**: đại diện cho đối tượng cần tạo, đối tượng này phức tạp, có nhiều thuộc tính.<br>- **Builder**: là abstract class hoặc interface khai báo phương thức tạo đối tượng.<br>- **ConcreteBuilder**: kế thừa Builder và cài đặt chi tiết cách tạo ra đối tượng. Nó sẽ xác định và nắm giữ các thể hiện mà nó tạo ra, đồng thời nó cũng cung cấp phương thức để trả các các thể hiện mà nó đã tạo ra trước đó.<br>- **Director/ Client**: là nơi sẽ gọi tới Builder để tạo ra đối tượng.<br><br>**[5. Ví dụ](designPattern.md#builder-pattern)** |
| **Structural Pattern (Mẫu Cấu trúc)**<br>Các pattern này tập trung vào việc **tổ chức và cấu trúc các đối tượng** để tạo thành một hệ thống lớn hơn, giúp chúng có thể làm việc cùng nhau một cách hiệu quả. |  |  |
|  | **Adapter Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/adapter-mini-2x.png)<br><br>**Độ khó**: ★★☆☆☆<br>**Mức độ phổ biến**: ★★★★☆ | **1. Định nghĩa**<br>- Cho phép các inteface (giao diện) không liên quan tới nhau có thể làm việc cùng nhau. Đối tượng giúp kết nối các interface gọi là Adapter.<br><img src="https://refactoring.guru/images/patterns/content/adapter/adapter-en-2x.png?id=e0ab0f6103b0b7b0648a8fda592ffab8" width="auto" height="200"> |
|  | **Bridge Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/bridge-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★☆☆ | **1. Định nghĩa**<br>- Giúp bạn tách một lớp khổng lồ hoặc một tập hợp lớp có quan hệ gần gũi với nhau thành hai hệ thống phân cấp lớp riêng biệt là - **abstraction(trừu tượng) và implementation(triển khai)** - có thể phát triển độc lập với nhau.<br><img src="https://refactoring.guru/images/patterns/content/bridge/bridge-2x.png?id=1e905ae5742e5cd10a7eb0e3175ef00d" width="auto" height="200"> |
|  | **Composite Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/composite-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★★☆ | **1. Định nghĩa**<br>- Là một sự tổng hợp những thành phần có quan hệ với nhau để tạo ra thành phần lớn hơn. Nó cho phép thực hiện các tương tác với tất cả đối tượng trong mẫu tương tự nhau.<br><img src="https://refactoring.guru/images/patterns/content/composite/composite-2x.png?id=8847e6f8e2cb892ed2229faba83bd1b7" width="auto" height="200"> |
|  | **Decorator Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/decorator-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★☆☆ | **1. Định nghĩa**<br>- Cho phép người dùng thêm chức năng mới vào đối tượng hiện tại mà không muốn ảnh hưởng đến các đối tượng khác. Kiểu thiết kế này có cấu trúc hoạt động như một lớp bao bọc (wrap) cho lớp hiện có. Mỗi khi cần thêm tính năng mới, đối tượng hiện có được wrap trong một đối tượng mới (decorator class).<br><img src="https://refactoring.guru/images/patterns/content/decorator/decorator-2x.png?id=736ab07b1d8920ab2c7a70c9cb1305cc" width="auto" height="200"> |
|  | **Facade Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/facade-mini-2x.png)<br><br>**Độ khó**: ★☆☆☆☆<br>**Mức độ phổ biến**: ★★★★★ | **1. Định nghĩa**<br>- Cho phép các đối tượng truy cập trực tiếp giao diện chung này để giao tiếp với các giao diện có trong hệ thống con. Mục tiêu là che giấu các hoạt động phức tạp bên trong hệ thống con, làm cho hệ thống con dễ sử dụng hơn.<br><img src="https://refactoring.guru/images/patterns/content/facade/facade-2x.png?id=b69fce5943703f5f07c0ba38e3baaed0" width="auto" height="200"> |
|  | **Flyweight Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/flyweight-mini-2x.png)<br><br>**Độ khó**: ★★★★☆<br>**Mức độ phổ biến**: ★☆☆☆☆ | **1. Định nghĩa**<br>- Là một mẫu thiết kế cấu trúc cho phép bạn lắp nhiều đối tượng hơn vào dung lượng RAM có sẵn bằng cách chia sẻ, phân phối các phần trạng thái chung - riêng giữa nhiều đối tượng thay vì giữ tất cả dữ liệu trong mỗi đối tượng.<br><img src="https://refactoring.guru/images/patterns/content/flyweight/flyweight-2x.png?id=6a8f17d9550c75c3d648a605c4d31b45" width="auto" height="200"> |
|  | **Proxy Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/proxy-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★★☆ | **1. Định nghĩa**<br>- Là mẫu thiết kế mà ở đó tất cả các truy cập trực tiếp đến một đối tượng nào đó sẽ được chuyển hướng vào một đối tượng trung gian (Proxy Class). Mẫu Proxy (người đại diện) đại diện cho một đối tượng khác thực thi các phương thức, phương thức đó có thể được định nghĩa lại cho phù hợp với múc đích sử dụng.<br><img src="https://refactoring.guru/images/patterns/content/proxy/proxy-2x.png?id=fb3d14e21c210a758d4777f4d93dce09" width="auto" height="200"> |
| **Behavioral Pattern (Mẫu Hành vi)**<br>Các pattern này tập trung vào việc xác định cách các đối tượng **giao tiếp và phối hợp hành vi với nhau** để đạt được những mục tiêu cụ thể. |  |  |
|  | **Chain of Responsibility Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/chain-of-responsibility-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★☆☆☆ | **1. Định nghĩa**<br>- Chain of Responsiblity cho phép một đối tượng gửi một yêu cầu nhưng không biết đối tượng nào sẽ nhận và xử lý nó. Điều này được thực hiện bằng cách kết nối các đối tượng nhận yêu cầu thành một chuỗi (chain) và gửi yêu cầu theo chuỗi đó cho đến khi có một đối tượng xử lý nó.<br><img src="https://refactoring.guru/images/patterns/content/chain-of-responsibility/chain-of-responsibility-2x.png?id=cc104b0a00a410f37fb39da80f392b88" width="auto" height="200"> |
|  | **Command Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/command-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★★☆ | **1. Định nghĩa**<br>- Command Pattern cho phép tất cả những Request gửi đến object được lưu trữ trong chính object đó dưới dạng một object Command. Khái niệm Command Object giống như một class trung gian được tạo ra để lưu trữ các câu lệnh và trạng thái của object tại một thời điểm nào đó.<br><img src="https://refactoring.guru/images/patterns/content/command/command-en-2x.png?id=6149af804cbbbd5cb18595c30b856d89" width="auto" height="200"> |
|  | **Interpreter Pattern**<br><br>**Độ khó**: ★★★★★<br>**Mức độ phổ biến**: ★☆☆☆☆ | **1. Định nghĩa**<br>- Interpreter Pattern giúp người lập trình có thể “xây dựng” những đối tượng “động” bằng cách đọc mô tả về đối tượng rồi sau đó “xây dựng” đối tượng đúng theo mô tả đó. |
|  | **Iterator Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/iterator-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★★★ | **1. Định nghĩa**<br>- Nó cho phép bạn lặp lại một tập hợp các phần tử mà không cần biết về cách thức lưu trữ của tập hợp.<br><img src="https://refactoring.guru/images/patterns/content/iterator/iterator-en-2x.png?id=2a85705e8e5fab257802b2ce36d6d236" width="auto" height="200"> |
|  | **Mediator Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/mediator-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★☆☆☆ | **1. Định nghĩa**<br>- Là mẫu thiết kế giúp giảm thiểu sự phụ thuộc giữa các đối tượng bằng cách sử dụng một đối tượng trung gian (mediator) để điều phối các tương tác giữa chúng.<br><img src="https://refactoring.guru/images/patterns/content/mediator/mediator-2x.png?id=250c2bf72ca1fdee2e6d97ed5a4765f2" width="auto" height="200"> |
|  | **Memento Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/memento-mini-2x.png)<br><br>**Độ khó**: ★★☆☆☆<br>**Mức độ phổ biến**: ★★☆☆☆ | **1. Định nghĩa**<br>- Là mẫu thiết kế giúp lưu trữ và phục hồi trạng thái của một đối tượng mà không làm lộ chi tiết nội bộ của đối tượng đó.<br><img src="https://refactoring.guru/images/patterns/content/memento/memento-en-2x.png?id=6782c5bbd8e036321dfd86558b540dda" width="auto" height="200"> |
|  | **Observer Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/observer-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★★★ | **1. Định nghĩa**<br>- Là mẫu thiết kế giúp cho phép các đối tượng được thông báo khi có sự thay đổi trong trạng thái của một đối tượng khác mà chúng quan tâm.<br><img src="https://refactoring.guru/images/patterns/content/observer/observer-2x.png?id=d5a83e115528e9fd633f04ad2650f1db" width="auto" height="200"> |
|  | **State Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/state-mini-2x.png)<br><br>**Độ khó**: ★★★☆☆<br>**Mức độ phổ biến**: ★★★☆☆ | **1. Định nghĩa**<br>- Là mẫu thiết kế giúp cho phép một đối tượng thay đổi hành vi của mình khi trạng thái của nó thay đổi.<br><img src="https://refactoring.guru/images/patterns/content/state/state-en-2x.png?id=dfd427a938223ae880291c2850f3e34a" width="auto" height="200"> |
|  | **Strategy Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/strategy-mini-2x.png)<br><br>**Độ khó**: ★☆☆☆☆<br>**Mức độ phổ biến**: ★★★★☆ | **1. Định nghĩa**<br>- Là một tập hợp các thuật toán giống nhau, đóng gói từng thuật toán lại, và dễ dàng thay đổi linh hoạt các thuật toán bên trong object. Strategy cho phép thuật toán biến đổi độc lập khi người dùng sử dụng chúng.<br><img src="https://refactoring.guru/images/patterns/content/strategy/strategy-2x.png?id=1cee47d05a76fddf07dce9c67b700748" width="auto" height="200"><br><br>**2. Ứng dụng**<br>- Khi muốn có thể thay đổi các thuật toán được sử dụng bên trong một đối tượng tại thời điểm run-time.<br>- Khi có một đoạn mã dễ thay đổi, và muốn tách chúng ra khỏi chương trình chính để dễ dàng bảo trì.<br>- Tránh sự rắc rối, khi phải hiện thực một chức năng nào đó qua quá nhiều lớp con.<br>- Cần che dấu sự phức tạp, cấu trúc bên trong của thuật toán.<br><br>**3. Ưu, nhược điểm**<br><br>- **Ưu điểm**:<br>    - **Đảm bảo nguyên tắc Single responsibility principle (SRP)**: một lớp định nghĩa nhiều hành vi và chúng xuất hiện dưới dạng với nhiều câu lệnh có điều kiện. Thay vì nhiều điều kiện, chúng ta sẽ chuyển các nhánh có điều kiện liên quan vào lớp Strategy riêng lẻ của nó.<br>    - **Đảm bảo nguyên tắc Open/Closed Principle (OCP)**: chúng ta dễ dàng mở rộng và kết hợp hành vi mới mà không thay đổi ứng dụng.<br>    - Cung cấp một sự thay thế cho kế thừa.<br><br>- **Nhược điểm**:<br>    - Không nên áp dụng nếu chỉ có một vài xử lý và hiếm khi thay đổi.    <br>    - Tăng số lượng lớp và mã code.<br>    - Khó khăn trong việc quản lý và kết hợp các strategy khác nhau.<br><br>**4. Cách triển khai**<br>- **Strategy**: định nghĩa các hành vi có thể có của một Strategy.<br>- **ConcreteStrategy**: cài đặt các hành vi cụ thể của Strategy.<br>- **Context**: chứa một tham chiếu đến đối tượng Strategy và nhận các yêu cầu từ Client, các yêu cầu này sau đó được ủy quyền cho Strategy thực hiện.<br><br>**[5. Ví dụ](designPattern.md#strategy-pattern)** |
|  | **Template Method Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/template-method-mini-2x.png)<br><br>**Độ khó**: ★★☆☆☆<br>**Mức độ phổ biến**: ★★★☆☆ | **1. Định nghĩa**<br>- Là pattern cung cấp một cấu trúc phương pháp chung, trong đó một số bước đã được định nghĩa sẵn và cho phép các lớp con tuỳ chỉnh một số bước cụ thể.<br><img src="https://refactoring.guru/images/patterns/content/template-method/template-method-2x.png?id=4e164dc41be4dcfa122628864c2be210" width="auto" height="200"><br><br>**2. Ứng dụng**<br>- Khi có một thuật toán với nhiều bước và mong muốn cho phép tùy chỉnh chúng trong lớp con.<br>- Mong muốn chỉ có một triển khai phương thức trừu tượng duy nhất của một thuật toán.<br>- Mong muốn hành vi chung giữa các lớp con nên được đặt ở một lớp chung.<br>- Các lớp cha có thể gọi các hành vi trong các lớp con của chúng một cách thống nhất (step by step).<br><br>**3. Ưu, nhược điểm**<br><br>- **Ưu điểm**:<br>    - Tái sử dụng code (reuse), tránh trùng lặp code (duplicate): đưa những phần trùng lặp vào lớp cha (abstract class).<br>    - Cho phép người dùng override chỉ một số phần nhất định của thuật toán lớn, làm cho chúng ít bị ảnh hưởng hơn bởi những thay đổi xảy ra với các phần khác của thuật toán.<br><br>- **Nhược điểm**: Template method có càng nhiều bước để override càng khó bảo trì.<br><br>**4. Cách triển khai**<br>- **AbstractClass**:<br>  - Định nghĩa các phương thức trừu tượng cho từng bước có thể được điều chỉnh bởi các lớp con.<br>  - Cài đặt một phương thức duy nhất điều khiển thuật toán và gọi các bước riêng lẻ đã được cài đặt ở các lớp con.<br>- **ConcreteClass**: là một thuật toán cụ thể, cài đặt các phương thức của AbstractClass. Các thuật toán này ghi đè lên các phương thức trừu tượng để cung cấp các triển khai thực sự. Nó không thể ghi đè phương thức duy nhất đã được cài đặt ở AbstractClass (templateMethod).<br><br>**[5. Ví dụ](designPattern.md#template-method)** |
|  | **Visitor Pattern**<br>![img](https://refactoring.guru/images/patterns/cards/visitor-mini-2x.png)<br><br>**Độ khó**: ★★★★☆<br>**Mức độ phổ biến**: ★☆☆☆☆ | **1. Định nghĩa**<br>- Là mẫu thiết kế giúp cho phép thực hiện một số hành động trên một đối tượng mà không cần thay đổi cấu trúc của đối tượng đó.<br><img src="https://refactoring.guru/images/patterns/content/visitor/visitor-2x.png?id=2c5d9ab3046d782c19809d3b80650d65" width="auto" height="200"> |

## Trình bày

- [Slide](https://www.canva.com/design/DAGUONosOjQ/Luq5Z3YJ2HEkSqBerT2KTQ/edit?utm_content=DAGUONosOjQ&utm_campaign=designshare&utm_medium=link2&utm_source=sharebutton)

## Tham khảo

- [refactoring.guru](https://refactoring.guru/design-patterns/catalog)

- [gpcoder.com](https://gpcoder.com/category/design-pattern/)
